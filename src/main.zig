//! By convention, main.zig is where your main function lives in the case that
//! you are building an executable. If you are making a library, the convention
//! is to delete this file and start with root.zig instead.


//t:  100010001010001110100
//b:  100101101000011100000
//x:  000111100010010010100 t xor b 
//r:  100111101010011110100 x | b
//t:  100000001000001100000 t & b
const std = @import("std");

// memory allocation can fail, so the return type is !void
const line_count = 30;
pub fn main() !void {
   var map: [line_count]u128 = .{0} ** line_count;
    map[0] =0b0000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;   
    map[1] =0b0000000000100000000000000000000000000000000000010000000100000000000000000000000000000000000000000000000000000000000000000000000;   
    map[2] =0b0000101000011000011000010010000010000010000010000100000000000000000000001000000000000100000000000000000000000000000000000000000;   
    map[3] =0b0000000000000000000010100100000001000000100000000000000000100000000001000000000000000000000000000000000000000000000000000000000;   
    map[4] =0b0000001000000001000010010011100000010000000000000000000000000000000000000000000000000000000000000000000000000100000000111000000;   
    map[5] =0b0000000000000000000010000100000000000000100000000000001000000000000000000000000000000000000000000000000000000100000000111000000;   
    map[6] =0b0000000010000010000000000100000000000000000000000000000000000000000000000000100000000001000000000000000000000100000000111000000;   
    map[7] =0b0000000100000000010001100001000011001000001000000000000000000000000000000000000000000000000000000000000000000100000000111000000;   
    map[8] =0b0000000000000000000000000000001000000000000000000000000000000000000000000100000000000000000000000000000000000100000000000000000;   
    map[9] =0b0000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000;   
    map[10] =0b0000000000000000000010100100000001000000100000000000000000100000000001000000000000000000000000000000000000000000000000000000000;   
    map[11] =0b0000001000000001000010010011100000010000000000000000000000000000000000000000000000000000000000000000000000000100000000111000000;   
    map[12] =0b0000000000000000000010000100000000000000100000000000001000000000000000000000000000000000000000000000000000000100000000111000000;   
    map[13] =0b0000000010000010000000000100000000000000000000000000000000000000000000000000100000000001000000000000000000000100000000111000000;   
    map[14] =0b0000001000000001000010010011100000010000000000000000000000000000000000000000000000000000000000000000000000000100000000111000000;   
    map[15] =0b0000000000000000000010000100000000000000100000000000001000000000000000000000000000000000000000000000000000000100000000111000000;   
    map[16] =0b0000000010000010000000000100000000000000000000000000000000000000000000000000100000000001000000000000000000000100000000111000000;   
    map[17] =0b0000000100000000010001100001000011001000001000000000000000000000000000000000000000000000000000000000000000000100000000111000000;   
    map[18] =0b0000000000000000000000000000001000000000000000000000000000000000000000000100000000000000000000000000000000000100000000000000000;   
    map[19] =0b0000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000;   
    var turns: i32 = line_count;
    while(turns > 0) : (turns-=1)
    {
        var lineIdx: usize = line_count-1;
        while(lineIdx > 0) : (lineIdx-=1)
        {
            {
                // check falling straight down
                const top = map[lineIdx-1];
                const bottom = map[lineIdx];

                map[lineIdx-1] = top & bottom;
                map[lineIdx] = (top ^ bottom) | bottom;
            }

            {
                // check falling straight down
                const top = map[lineIdx-1] >> 1;
                const bottom = map[lineIdx];

                map[lineIdx-1] = (top & bottom) << 1;
                map[lineIdx] = (top ^ bottom) | bottom;
            } 

            {
                // check falling straight down
                const top = map[lineIdx-1] << 1;
                const bottom = map[lineIdx];

                map[lineIdx-1] = (top & bottom) >> 1;
                map[lineIdx] = (top ^ bottom) | bottom;
            }
        }
        std.time.sleep(40_000_000);

        try print(&map);
    }

    
}
fn print(map: *[line_count]u128) !void
{

const stdout = std.io.getStdOut().writer();
        // Move cursor to top-left without clearing
        try stdout.writeAll("\x1B[H"); // ANSI escape code: move cursor to 0,0

        // Render content to a buffer first (optional but helps with flicker)
        var buffer: [128*line_count+line_count*2]u8 = undefined;
        var stream = std.io.fixedBufferStream(&buffer);
        const writer = stream.writer();
       

    for(map) |line|{
        comptime var i: u7 = 127;
        inline while (i > 0) : (i-=1) {
            const bit: u8 = if((line >> i) % 2 == 1) 'X' else ' ';
            try writer.print("{c}", .{bit});
        }
        try writer.print("\n", .{});
    }

// Write whole buffer at once
        try stdout.writeAll(stream.getWritten());
}

